diff --git a/app/_layout.tsx b/app/_layout.tsx
index 9a06240..8d99f6d 100644
--- a/app/_layout.tsx
+++ b/app/_layout.tsx
@@ -10,6 +10,7 @@ export default function RootLayout() {
       <Stack.Screen name="company-login" />
       <Stack.Screen name="(auth)" />
       <Stack.Screen name="create-survey" />
+      <Stack.Screen name="screens/MetricScreen" />
     </Stack>
     </AuthProvider>
   );
diff --git a/app/chat.tsx b/app/chat.tsx
index a745d50..4741516 100644
--- a/app/chat.tsx
+++ b/app/chat.tsx
@@ -3,6 +3,7 @@ import { View, Text, StyleSheet, TouchableOpacity, TextInput, ScrollView, Image,
 import { router, useLocalSearchParams } from "expo-router";
 import { chatService } from "./services/chatService";
 import { getSurveyById } from "./firebase/firebase";
+import { useAuth } from "./context/AuthContext";
 
 const userAvatar = "https://randomuser.me/api/portraits/women/2.jpg";
 const noahAvatar = "https://randomuser.me/api/portraits/men/1.jpg";
@@ -13,6 +14,12 @@ interface Message {
   isUser: boolean;
 }
 
+interface Survey {
+  id: string;
+  title: string;
+  context?: string;
+}
+
 export default function ChatScreen() {
   const { surveyId } = useLocalSearchParams();
   const [messages, setMessages] = useState<Message[]>([]);
@@ -22,11 +29,19 @@ export default function ChatScreen() {
   const [error, setError] = useState<string | null>(null);
   const [surveyTitle, setSurveyTitle] = useState<string>("");
   const scrollViewRef = useRef<ScrollView>(null);
+  const { user } = useAuth();
+
+  useEffect(() => {
+    if (!user) {
+      router.replace("/");
+      return;
+    }
+  }, [user]);
 
   // Initialize chat with first message
   useEffect(() => {
-    if (!surveyId) {
-      setError('No survey ID provided');
+    if (!surveyId || !user) {
+      setError('No survey ID or user provided');
       setIsInitializing(false);
       return;
     }
@@ -37,7 +52,7 @@ export default function ChatScreen() {
         setError(null);
 
         // Load existing messages for this survey
-        const existingMessages = chatService.getContext(surveyId as string);
+        const existingMessages = chatService.getContext(surveyId as string, user.id);
         if (existingMessages.length > 0) {
           const formattedMessages = existingMessages.map(msg => ({
             id: Date.now().toString() + Math.random(),
@@ -47,7 +62,7 @@ export default function ChatScreen() {
           setMessages(formattedMessages);
         } else {
           // If no existing messages, fetch survey data and create initial message
-          const survey = await getSurveyById(surveyId as string);
+          const survey = await getSurveyById(surveyId as string) as Survey;
           if (survey) {
             setSurveyTitle(survey.title);
             const initialMessage: Message = {
@@ -67,7 +82,7 @@ export default function ChatScreen() {
     };
 
     initializeChat();
-  }, [surveyId]);
+  }, [surveyId, user]);
 
   // Scroll to bottom when messages change
   useEffect(() => {
@@ -77,11 +92,11 @@ export default function ChatScreen() {
   }, [messages]);
 
   const handleSend = async () => {
-    if (!inputText.trim() || isLoading || !surveyId) return;
+    if (!inputText.trim() || !user) return;
 
-    const userMessage: Message = {
+    const userMessage = {
       id: Date.now().toString(),
-      text: inputText.trim(),
+      text: inputText,
       isUser: true
     };
 
@@ -90,21 +105,21 @@ export default function ChatScreen() {
     setIsLoading(true);
 
     try {
-      const response = await chatService.sendMessage(surveyId as string, userMessage.text);
+      const response = await chatService.sendMessage(surveyId as string, inputText, user.id);
       
-      const aiMessage: Message = {
+      const assistantMessage = {
         id: (Date.now() + 1).toString(),
         text: response,
         isUser: false
       };
 
-      setMessages(prev => [...prev, aiMessage]);
+      setMessages(prev => [...prev, assistantMessage]);
     } catch (error) {
-      console.error('Error sending message:', error);
+      console.error("Error sending message:", error);
       // Add error message to chat
-      const errorMessage: Message = {
+      const errorMessage = {
         id: (Date.now() + 1).toString(),
-        text: 'Sorry, I encountered an error. Please try again.',
+        text: "I apologize, but I'm having trouble processing your message right now. Please try again.",
         isUser: false
       };
       setMessages(prev => [...prev, errorMessage]);
@@ -192,6 +207,47 @@ export default function ChatScreen() {
 
         {/* Input area */}
         <View style={styles.inputRow}>
+          {/* Quick Response Buttons */}
+          <View style={styles.quickResponsesRow}>
+            {['I don\'t like it', 'I like it', 'Maybe'].map((text) => (
+              <TouchableOpacity
+                key={text}
+                style={styles.quickResponseButton}
+                onPress={async () => {
+                  if (isLoading || !surveyId) return;
+                  const userMessage = {
+                    id: Date.now().toString(),
+                    text,
+                    isUser: true
+                  };
+                  setMessages(prev => [...prev, userMessage]);
+                  setInputText("");
+                  setIsLoading(true);
+                  try {
+                    const response = await chatService.sendMessage(surveyId as string, text);
+                    const aiMessage = {
+                      id: (Date.now() + 1).toString(),
+                      text: response,
+                      isUser: false
+                    };
+                    setMessages(prev => [...prev, aiMessage]);
+                  } catch (error) {
+                    const errorMessage = {
+                      id: (Date.now() + 1).toString(),
+                      text: 'Sorry, I encountered an error. Please try again.',
+                      isUser: false
+                    };
+                    setMessages(prev => [...prev, errorMessage]);
+                  } finally {
+                    setIsLoading(false);
+                  }
+                }}
+                disabled={isLoading}
+              >
+                <Text style={styles.quickResponseText}>{text}</Text>
+              </TouchableOpacity>
+            ))}
+          </View>
           <TouchableOpacity><Text style={styles.plus}>+</Text></TouchableOpacity>
           <TextInput
             style={styles.input}
@@ -227,7 +283,14 @@ const styles = StyleSheet.create({
   senderRight: { fontWeight: "600", fontSize: 13, color: "#3B217F", textAlign: "right" },
   bubbleLeft: { backgroundColor: "#f3f3f3", borderRadius: 16, padding: 10, marginBottom: 4, maxWidth: 220 },
   bubbleRight: { backgroundColor: "#7B61FF", borderRadius: 16, padding: 10, marginBottom: 4, maxWidth: 220, alignSelf: "flex-end" },
-  inputRow: { flexDirection: "row", alignItems: "center", padding: 8, borderTopWidth: 1, borderColor: "#eee", backgroundColor: "#fff" },
+  inputRow: { 
+    flexDirection: "row", 
+    alignItems: "center", 
+    padding: 12,
+    backgroundColor: "#fff",
+    borderTopWidth: 1,
+    borderColor: "#eee",
+  },
   plus: { fontSize: 24, color: "#7B61FF", marginHorizontal: 8 },
   input: { flex: 1, backgroundColor: "#f3f3f3", borderRadius: 20, paddingHorizontal: 16, paddingVertical: 8, fontSize: 16, marginHorizontal: 8 },
   send: { fontSize: 24, color: "#7B61FF", marginHorizontal: 8 },
@@ -258,4 +321,30 @@ const styles = StyleSheet.create({
     fontSize: 16,
     fontWeight: '600',
   },
+  quickResponsesRow: {
+    flexDirection: 'row',
+    justifyContent: 'space-around',
+    paddingHorizontal: 16,
+    paddingVertical: 8,
+    backgroundColor: '#fff',
+    borderTopWidth: 1,
+    borderColor: '#eee',
+  },
+  quickResponseButton: {
+    backgroundColor: '#F0EEFF',
+    borderRadius: 20,
+    paddingHorizontal: 16,
+    paddingVertical: 8,
+    marginHorizontal: 4,
+    borderWidth: 1,
+    borderColor: '#7B61FF',
+    minWidth: 100,
+    alignItems: 'center',
+  },
+  quickResponseText: {
+    color: '#3B217F',
+    fontWeight: '600',
+    fontSize: 14,
+    textAlign: 'center',
+  },
 }); 
\ No newline at end of file
diff --git a/app/config.ts b/app/config.ts
new file mode 100644
index 0000000..0c159b3
--- /dev/null
+++ b/app/config.ts
@@ -0,0 +1,12 @@
+import Constants from 'expo-constants';
+
+// Get API key from Expo's environment variables
+const OPENAI_API_KEY = Constants.expoConfig?.extra?.openaiApiKey;
+
+if (!OPENAI_API_KEY) {
+  console.warn('Warning: OPENAI_API_KEY is not set in app.config.js');
+}
+
+export const config = {
+  openaiApiKey: OPENAI_API_KEY
+}; 
\ No newline at end of file
diff --git a/app/firebase/firebase.ts b/app/firebase/firebase.ts
index cbb0169..778a07c 100644
--- a/app/firebase/firebase.ts
+++ b/app/firebase/firebase.ts
@@ -441,7 +441,7 @@ export const getSurveyById = async (surveyId: string) => {
 };
 
 // Function to get survey questions
-export const getSurveyQuestions = async (surveyId: string) => {
+export const getSurveyQuestions = async (surveyId: string): Promise<{ id: string; questionText: string; order: number }[]> => {
   try {
     const questionsRef = collection(db, `companies/LEyaRS2Mv7CLzP20K0Pe/surveys/${surveyId}/questions`);
     const querySnapshot = await getDocs(questionsRef);
@@ -449,7 +449,8 @@ export const getSurveyQuestions = async (surveyId: string) => {
     return querySnapshot.docs
       .map(doc => ({
         id: doc.id,
-        ...doc.data()
+        questionText: doc.data().questionText,
+        order: doc.data().order
       }))
       .sort((a, b) => a.order - b.order); // Sort by order
   } catch (error) {
diff --git a/app/screens/MetricScreen.tsx b/app/screens/MetricScreen.tsx
index b47f140..83d553d 100644
--- a/app/screens/MetricScreen.tsx
+++ b/app/screens/MetricScreen.tsx
@@ -1,148 +1,395 @@
-import React from "react";
+import React, { useState, useEffect } from 'react';
 import {
   View,
   Text,
   StyleSheet,
-  SafeAreaView,
   ScrollView,
   TouchableOpacity,
-} from "react-native";
-import { router } from "expo-router";
-
-export default function SurveySummaryScreen() {
-  const keywords1 = [
-    { id: 1, text: "Too bright", color: "#FFB800" },
-    { id: 2, text: "Crowded", color: "#9747FF" },
-    { id: 3, text: "Love it!", color: "#FF4747" },
-    { id: 4, text: "Creative", color: "#666666" },
-    { id: 5, text: "Meh...", color: "#1E7F2C" },
-  ];
-
-  const keywords2 = [
-    { id: 1, text: "Too bright", color: "#FFB800" },
-    { id: 2, text: "Hangout", color: "#9747FF" },
-    { id: 3, text: "Cooking", color: "#FF4747" },
-    { id: 4, text: "Other", color: "#666666" },
-    { id: 5, text: "Weekend", color: "#1E7F2C" },
-  ];
+  ActivityIndicator,
+  SafeAreaView,
+} from 'react-native';
+import { useLocalSearchParams, router } from 'expo-router';
+import { doc, getDoc, collection, getDocs } from 'firebase/firestore';
+import { db } from '../firebase/firebase';
+
+interface ResponseData {
+  text: string;
+  sentiment: 'positive' | 'negative' | 'neutral';
+}
+
+interface QuestionMetrics {
+  questionText: string;
+  responses: ResponseData[];
+  metrics: {
+    positive: number;
+    negative: number;
+    neutral: number;
+    keywords: {
+      [key: string]: {
+        count: number;
+        sentiment: 'positive' | 'negative' | 'neutral';
+        examples: string[];
+      }
+    }
+  };
+  totalResponses: number;
+}
+
+interface Question {
+  id: string;
+  questionText: string;
+  order: number;
+}
+
+interface KeywordType {
+  text: string;
+  color: string;
+  count: number;
+  sentiment: 'positive' | 'negative' | 'neutral';
+}
+
+const SENTIMENT_CATEGORIES = {
+  positive: {
+    keywords: ['yes', 'like', 'good', 'love', 'great', 'awesome', 'perfect', 'excellent', 'amazing', 'wonderful'],
+    color: '#7AD6B9'  // Green
+  },
+  negative: {
+    keywords: ['no', 'don\'t like', 'bad', 'hate', 'terrible', 'awful', 'dislike', 'poor', 'worst', 'unhappy'],
+    color: '#E6A7A7'  // Red
+  },
+  neutral: {
+    keywords: ['maybe', 'okay', 'somewhat', 'sometimes', 'depends', 'unsure', 'not sure'],
+    color: '#B6A7E6'  // Purple
+  }
+};
+
+const MetricScreen = () => {
+  const { surveyId } = useLocalSearchParams();
+  const [isLoading, setIsLoading] = useState(true);
+  const [metrics, setMetrics] = useState<QuestionMetrics[]>([]);
+  const [error, setError] = useState<string | null>(null);
+
+  useEffect(() => {
+    fetchMetrics();
+  }, [surveyId]);
+
+  const fetchMetrics = async () => {
+    try {
+      setIsLoading(true);
+      setError(null);
+
+      // Get survey responses
+      const answersRef = doc(db, `companies/LEyaRS2Mv7CLzP20K0Pe/surveys/${surveyId}/metadata/answers`);
+      const answersDoc = await getDoc(answersRef);
+      const responses = answersDoc.data()?.responses || {};
+
+      // Get questions
+      const questionsRef = collection(db, `companies/LEyaRS2Mv7CLzP20K0Pe/surveys/${surveyId}/questions`);
+      const questionsSnapshot = await getDocs(questionsRef);
+      const questions = questionsSnapshot.docs
+        .map(doc => ({
+          id: doc.id,
+          ...doc.data()
+        } as Question))
+        .sort((a, b) => a.order - b.order);
+
+      // Process metrics for each question
+      const questionMetrics: QuestionMetrics[] = questions.map((question: Question) => {
+        // Get all responses for this question with their full text
+        const questionResponses: ResponseData[] = Object.entries(responses)
+          .map(([username, userResponses]: [string, any]) => {
+            const response = userResponses[question.id];
+            if (!response) return null;
+
+            // Determine sentiment for this response
+            const lowerResponse = response.toLowerCase();
+            let sentiment: 'positive' | 'negative' | 'neutral' = 'neutral';
+
+            if (SENTIMENT_CATEGORIES.positive.keywords.some(keyword => lowerResponse.includes(keyword))) {
+              sentiment = 'positive';
+            } else if (SENTIMENT_CATEGORIES.negative.keywords.some(keyword => lowerResponse.includes(keyword))) {
+              sentiment = 'negative';
+            }
+
+            return {
+              text: response,
+              sentiment
+            };
+          })
+          .filter((r): r is ResponseData => r !== null);
+
+        // Initialize metrics
+        const metrics = {
+          positive: 0,
+          negative: 0,
+          neutral: 0,
+          keywords: {} as { [key: string]: { count: number; sentiment: 'positive' | 'negative' | 'neutral'; examples: string[] } }
+        };
+
+        // Process each response
+        questionResponses.forEach(response => {
+          // Count sentiments
+          metrics[response.sentiment]++;
+
+          // Extract and categorize keywords
+          const words = response.text
+            .toLowerCase()
+            .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '')
+            .split(/\s+/)
+            .filter(word => word.length > 3);
+
+          words.forEach(word => {
+            if (!metrics.keywords[word]) {
+              metrics.keywords[word] = {
+                count: 0,
+                sentiment: response.sentiment,
+                examples: []
+              };
+            }
+            metrics.keywords[word].count++;
+            if (!metrics.keywords[word].examples.includes(response.text) && 
+                metrics.keywords[word].examples.length < 3) {
+              metrics.keywords[word].examples.push(response.text);
+            }
+          });
+        });
+
+        return {
+          questionText: question.questionText,
+          responses: questionResponses,
+          metrics,
+          totalResponses: questionResponses.length
+        };
+      });
+
+      setMetrics(questionMetrics);
+    } catch (error) {
+      console.error('Error fetching metrics:', error);
+      setError('Failed to load metrics. Please try again.');
+    } finally {
+      setIsLoading(false);
+    }
+  };
+
+  const assignKeywordColors = (keywords: { [key: string]: { count: number; sentiment: string } }): KeywordType[] => {
+    return Object.entries(keywords)
+      .map(([text, { count, sentiment }]) => ({
+        text,
+        count,
+        sentiment: sentiment as 'positive' | 'negative' | 'neutral',
+        color: SENTIMENT_CATEGORIES[sentiment as keyof typeof SENTIMENT_CATEGORIES].color
+      }))
+      .sort((a, b) => b.count - a.count)
+      .slice(0, 5);
+  };
+
+  if (isLoading) {
+    return (
+      <View style={styles.centerContainer}>
+        <ActivityIndicator size="large" color="#7B61FF" />
+        <Text style={styles.loadingText}>Loading metrics...</Text>
+      </View>
+    );
+  }
+
+  if (error) {
+    return (
+      <View style={styles.centerContainer}>
+        <Text style={styles.errorText}>{error}</Text>
+      </View>
+    );
+  }
 
   return (
-    <SafeAreaView style={styles.safeArea}>
+    <SafeAreaView style={styles.container}>
       <View style={styles.header}>
-        <TouchableOpacity 
-          onPress={() => router.back()}
-          style={styles.closeButton}
-        >
-          <Text style={styles.closeIcon}>×</Text>
+        <TouchableOpacity onPress={() => router.back()}>
+          <Text style={styles.closeButton}>×</Text>
         </TouchableOpacity>
-        <Text style={styles.headerTitle}>Tag Feature Summary</Text>
-        <TouchableOpacity style={styles.settingsButton}>
-          <Text style={styles.settingsIcon}>⚙️</Text>
+        <Text style={styles.title}>Survey Results</Text>
+        <TouchableOpacity>
+          <Text style={styles.settingsButton}>⚙️</Text>
         </TouchableOpacity>
       </View>
 
       <ScrollView style={styles.content}>
-        <View style={styles.questionCard}>
-          <Text style={styles.questionTitle}>Q1. What are your thoughts on the UI</Text>
-          <Text style={styles.subtitle}>Here's what they said...</Text>
-
-          <View style={styles.statsContainer}>
-            <View style={styles.statRow}>
-              <View style={[styles.statBar, { width: '60%' }]} />
-              <Text style={styles.statText}>60% users loved it</Text>
-            </View>
-            <View style={styles.statRow}>
-              <View style={[styles.statBar, { width: '30%' }]} />
-              <Text style={styles.statText}>30% users don't like it</Text>
-            </View>
-            <View style={styles.statRow}>
-              <View style={[styles.statBar, { width: '10%' }]} />
-              <Text style={styles.statText}>10% users kinda liked it</Text>
-            </View>
-          </View>
-
-          <Text style={styles.keywordsTitle}>Keywords</Text>
-          <View style={styles.keywordsContainer}>
-            {keywords1.map((keyword) => (
-              <View 
-                key={keyword.id}
-                style={[styles.keywordPill, { backgroundColor: keyword.color + '20' }]}
-              >
-                <View style={[styles.keywordDot, { backgroundColor: keyword.color }]} />
-                <Text style={styles.keywordText}>{keyword.text}</Text>
+        {metrics.map((questionMetric, index) => {
+          const { positive, negative, neutral } = questionMetric.metrics;
+          const total = questionMetric.totalResponses;
+          
+          const positivePercentage = Math.round((positive / total) * 100) || 0;
+          const negativePercentage = Math.round((negative / total) * 100) || 0;
+          const neutralPercentage = Math.round((neutral / total) * 100) || 0;
+
+          // Get top keywords for each sentiment
+          const getTopKeywords = (sentiment: 'positive' | 'negative' | 'neutral') => {
+            return Object.entries(questionMetric.metrics.keywords)
+              .filter(([_, data]) => data.sentiment === sentiment)
+              .sort((a, b) => b[1].count - a[1].count)
+              .slice(0, 3)
+              .map(([word, data]) => ({
+                text: word,
+                count: data.count,
+                color: SENTIMENT_CATEGORIES[sentiment].color,
+                examples: data.examples
+              }));
+          };
+
+          const positiveKeywords = getTopKeywords('positive');
+          const negativeKeywords = getTopKeywords('negative');
+          const neutralKeywords = getTopKeywords('neutral');
+
+          return (
+            <View key={index} style={styles.questionCard}>
+              <Text style={styles.questionText}>Q{index + 1}. {questionMetric.questionText}</Text>
+              <Text style={styles.subheader}>Total Responses: {total}</Text>
+
+              {/* Sentiment Distribution */}
+              <View style={styles.sentimentSection}>
+                <Text style={styles.sectionTitle}>Sentiment Distribution</Text>
+                <View style={styles.metricsContainer}>
+                  {positive > 0 && (
+                    <View style={styles.metricSection}>
+                      <View style={styles.metricRow}>
+                        <View style={[styles.dot, { backgroundColor: SENTIMENT_CATEGORIES.positive.color }]} />
+                        <Text style={styles.metricLabel}>Positive</Text>
+                        <Text style={styles.metricValue}>{positivePercentage}%</Text>
+                      </View>
+                      <View style={styles.progressBarContainer}>
+                        <View 
+                          style={[
+                            styles.progressBar,
+                            { 
+                              width: `${positivePercentage}%`,
+                              backgroundColor: SENTIMENT_CATEGORIES.positive.color
+                            }
+                          ]} 
+                        />
+                      </View>
+                    </View>
+                  )}
+
+                  {negative > 0 && (
+                    <View style={styles.metricSection}>
+                      <View style={styles.metricRow}>
+                        <View style={[styles.dot, { backgroundColor: SENTIMENT_CATEGORIES.negative.color }]} />
+                        <Text style={styles.metricLabel}>Negative</Text>
+                        <Text style={styles.metricValue}>{negativePercentage}%</Text>
+                      </View>
+                      <View style={styles.progressBarContainer}>
+                        <View 
+                          style={[
+                            styles.progressBar,
+                            { 
+                              width: `${negativePercentage}%`,
+                              backgroundColor: SENTIMENT_CATEGORIES.negative.color
+                            }
+                          ]} 
+                        />
+                      </View>
+                    </View>
+                  )}
+
+                  {neutral > 0 && (
+                    <View style={styles.metricSection}>
+                      <View style={styles.metricRow}>
+                        <View style={[styles.dot, { backgroundColor: SENTIMENT_CATEGORIES.neutral.color }]} />
+                        <Text style={styles.metricLabel}>Neutral</Text>
+                        <Text style={styles.metricValue}>{neutralPercentage}%</Text>
+                      </View>
+                      <View style={styles.progressBarContainer}>
+                        <View 
+                          style={[
+                            styles.progressBar,
+                            { 
+                              width: `${neutralPercentage}%`,
+                              backgroundColor: SENTIMENT_CATEGORIES.neutral.color
+                            }
+                          ]} 
+                        />
+                      </View>
+                    </View>
+                  )}
+                </View>
               </View>
-            ))}
-          </View>
-        </View>
-
-        <View style={styles.questionCard}>
-          <Text style={styles.questionTitle}>Q2. What are your thoughts on the UI</Text>
-          <Text style={styles.subtitle}>Here's what they said...</Text>
-
-          <View style={styles.statsContainer}>
-            <View style={styles.statRow}>
-              <View style={[styles.statBar, { width: '60%' }]} />
-              <Text style={styles.statText}>60% users said yes</Text>
-            </View>
-            <View style={styles.statRow}>
-              <View style={[styles.statBar, { width: '30%' }]} />
-              <Text style={styles.statText}>30% users said no</Text>
-            </View>
-          </View>
-
-          <Text style={styles.keywordsTitle}>Keywords</Text>
-          <View style={styles.keywordsContainer}>
-            {keywords2.map((keyword) => (
-              <View 
-                key={keyword.id}
-                style={[styles.keywordPill, { backgroundColor: keyword.color + '20' }]}
-              >
-                <View style={[styles.keywordDot, { backgroundColor: keyword.color }]} />
-                <Text style={styles.keywordText}>{keyword.text}</Text>
+
+              {/* Keywords Section */}
+              <View style={styles.keywordsSection}>
+                <Text style={styles.sectionTitle}>Common Keywords</Text>
+                
+                {positiveKeywords.length > 0 && (
+                  <View style={styles.keywordCategory}>
+                    <Text style={styles.keywordCategoryTitle}>Positive Keywords</Text>
+                    <View style={styles.keywordContainer}>
+                      {positiveKeywords.map((keyword, idx) => (
+                        <View key={idx} style={styles.keywordWrapper}>
+                          <View style={[styles.keywordDot, { backgroundColor: keyword.color }]} />
+                          <Text style={styles.keywordText}>{keyword.text} ({keyword.count})</Text>
+                        </View>
+                      ))}
+                    </View>
+                  </View>
+                )}
+
+                {negativeKeywords.length > 0 && (
+                  <View style={styles.keywordCategory}>
+                    <Text style={styles.keywordCategoryTitle}>Negative Keywords</Text>
+                    <View style={styles.keywordContainer}>
+                      {negativeKeywords.map((keyword, idx) => (
+                        <View key={idx} style={styles.keywordWrapper}>
+                          <View style={[styles.keywordDot, { backgroundColor: keyword.color }]} />
+                          <Text style={styles.keywordText}>{keyword.text} ({keyword.count})</Text>
+                        </View>
+                      ))}
+                    </View>
+                  </View>
+                )}
+
+                {neutralKeywords.length > 0 && (
+                  <View style={styles.keywordCategory}>
+                    <Text style={styles.keywordCategoryTitle}>Neutral Keywords</Text>
+                    <View style={styles.keywordContainer}>
+                      {neutralKeywords.map((keyword, idx) => (
+                        <View key={idx} style={styles.keywordWrapper}>
+                          <View style={[styles.keywordDot, { backgroundColor: keyword.color }]} />
+                          <Text style={styles.keywordText}>{keyword.text} ({keyword.count})</Text>
+                        </View>
+                      ))}
+                    </View>
+                  </View>
+                )}
               </View>
-            ))}
-            <TouchableOpacity style={styles.addKeywordButton}>
-              <Text style={styles.addKeywordText}>+</Text>
-            </TouchableOpacity>
-          </View>
-        </View>
-
-        <View style={styles.summarySection}>
-          <Text style={styles.summaryTitle}>Summary</Text>
-          <Text style={styles.summaryText}>Insights on tagging feature...</Text>
-        </View>
+            </View>
+          );
+        })}
       </ScrollView>
     </SafeAreaView>
   );
-}
+};
 
 const styles = StyleSheet.create({
-  safeArea: {
+  container: {
     flex: 1,
-    backgroundColor: "#FFFFFF",
+    backgroundColor: '#FFFFFF',
   },
   header: {
-    flexDirection: "row",
-    justifyContent: "space-between",
-    alignItems: "center",
+    flexDirection: 'row',
+    justifyContent: 'space-between',
+    alignItems: 'center',
     padding: 16,
     borderBottomWidth: 1,
-    borderBottomColor: "#E5E5E5",
+    borderBottomColor: '#E5E5E5',
   },
-  closeButton: {
-    padding: 8,
+  title: {
+    fontSize: 18,
+    fontWeight: '600',
+    color: '#333333',
   },
-  closeIcon: {
+  closeButton: {
     fontSize: 24,
-  },
-  headerTitle: {
-    fontSize: 18,
-    fontWeight: "600",
+    color: '#333333',
   },
   settingsButton: {
-    padding: 8,
-  },
-  settingsIcon: {
     fontSize: 20,
   },
   content: {
@@ -150,108 +397,122 @@ const styles = StyleSheet.create({
     padding: 16,
   },
   questionCard: {
-    backgroundColor: "#F4F0FF",
-    borderRadius: 24,
-    padding: 20,
-    marginBottom: 20,
+    backgroundColor: '#FFFFFF',
+    borderRadius: 12,
+    padding: 16,
+    marginBottom: 16,
     shadowColor: '#000',
     shadowOffset: { width: 0, height: 2 },
-    shadowOpacity: 0.06,
-    shadowRadius: 8,
+    shadowOpacity: 0.1,
+    shadowRadius: 4,
+    elevation: 3,
   },
-  questionTitle: {
-    fontSize: 17,
-    fontWeight: "700",
-    marginBottom: 4,
-    color: "#181818",
+  questionText: {
+    fontSize: 16,
+    fontWeight: '600',
+    color: '#333333',
+    marginBottom: 8,
   },
-  subtitle: {
+  subheader: {
     fontSize: 14,
-    color: "#6B6B6B",
+    color: '#666666',
     marginBottom: 16,
-    fontWeight: "400",
   },
-  statsContainer: {
+  sectionTitle: {
+    fontSize: 15,
+    fontWeight: '600',
+    color: '#333333',
+    marginBottom: 12,
+  },
+  sentimentSection: {
     marginBottom: 24,
   },
-  statRow: {
-    marginBottom: 12,
+  metricsContainer: {
+    gap: 12,
+  },
+  metricSection: {
+    gap: 4,
   },
-  statBar: {
+  metricRow: {
+    flexDirection: 'row',
+    alignItems: 'center',
+    gap: 8,
+  },
+  dot: {
+    width: 8,
+    height: 8,
+    borderRadius: 4,
+  },
+  metricLabel: {
+    flex: 1,
+    fontSize: 14,
+    color: '#333333',
+  },
+  metricValue: {
+    fontSize: 14,
+    fontWeight: '500',
+    color: '#333333',
+  },
+  progressBarContainer: {
     height: 6,
-    backgroundColor: "#7B61FF",
+    backgroundColor: '#F0F0F0',
     borderRadius: 3,
-    marginBottom: 4,
+    overflow: 'hidden',
   },
-  statText: {
-    fontSize: 14,
-    color: "#6B6B6B",
-    marginLeft: 0,
-    fontWeight: "400",
+  progressBar: {
+    height: '100%',
+    borderRadius: 3,
   },
-  keywordsTitle: {
-    fontSize: 15,
-    fontWeight: "600",
-    marginBottom: 10,
-    color: "#181818",
+  keywordsSection: {
+    gap: 16,
   },
-  keywordsContainer: {
-    flexDirection: "row",
-    flexWrap: "wrap",
+  keywordCategory: {
     gap: 8,
-    marginBottom: 0,
   },
-  keywordPill: {
-    flexDirection: "row",
-    alignItems: "center",
-    paddingVertical: 4,
+  keywordCategoryTitle: {
+    fontSize: 14,
+    fontWeight: '500',
+    color: '#666666',
+  },
+  keywordContainer: {
+    flexDirection: 'row',
+    flexWrap: 'wrap',
+    gap: 8,
+  },
+  keywordWrapper: {
+    flexDirection: 'row',
+    alignItems: 'center',
+    backgroundColor: '#F5F5F5',
+    paddingVertical: 6,
     paddingHorizontal: 12,
     borderRadius: 16,
     gap: 6,
-    marginBottom: 8,
   },
   keywordDot: {
-    width: 8,
-    height: 8,
-    borderRadius: 4,
+    width: 6,
+    height: 6,
+    borderRadius: 3,
   },
   keywordText: {
-    fontSize: 14,
-    color: "#181818",
-    fontWeight: "500",
+    fontSize: 12,
+    color: '#333333',
   },
-  addKeywordButton: {
-    width: 28,
-    height: 28,
-    borderRadius: 14,
-    borderWidth: 1,
-    borderColor: "#E0E0E0",
-    alignItems: "center",
-    justifyContent: "center",
-    backgroundColor: "#F4F0FF",
-    marginBottom: 8,
-  },
-  addKeywordText: {
-    fontSize: 18,
-    color: "#7B61FF",
-    fontWeight: "700",
-  },
-  summarySection: {
-    marginTop: 8,
-    marginBottom: 24,
-    backgroundColor: '#FFFDEB',
-    borderRadius: 16,
-    padding: 16,
+  centerContainer: {
+    flex: 1,
+    justifyContent: 'center',
+    alignItems: 'center',
   },
-  summaryTitle: {
+  loadingText: {
+    marginTop: 16,
     fontSize: 16,
-    fontWeight: "600",
-    marginBottom: 8,
-    color: "#181818",
+    color: '#666666',
   },
-  summaryText: {
-    fontSize: 14,
-    color: "#6B6B6B",
-    fontWeight: "400",
+  errorText: {
+    fontSize: 16,
+    color: '#E6A7A7',
+    textAlign: 'center',
+    padding: 16,
   },
-}); 
\ No newline at end of file
+});
+
+export default MetricScreen; 
\ No newline at end of file
diff --git a/app/services/chatService.ts b/app/services/chatService.ts
index d66effb..1a5f979 100644
--- a/app/services/chatService.ts
+++ b/app/services/chatService.ts
@@ -1,15 +1,18 @@
 import { config } from '../config';
-import { doc, getDoc } from 'firebase/firestore';
+import { doc, getDoc, collection, addDoc, updateDoc, arrayUnion } from 'firebase/firestore';
 import { db } from '../firebase/firebase';
 import { getSurveyQuestions } from '../firebase/firebase';
 
 interface Message {
-  role: 'user' | 'assistant';
+  role: 'user' | 'assistant' | 'system';
   content: string;
+  timestamp: number;
 }
 
 interface ChatContext {
   chatId: string;
+  userId: string;
+  chatDocId: string;
   messages: Message[];
   currentQuestionIndex: number;
   questions: { id: string; questionText: string; order: number }[];
@@ -22,9 +25,14 @@ interface ChatContext {
 export const chatService = {
   chatContexts: new Map<string, ChatContext>(),
 
-  async sendMessage(chatId: string, message: string) {
+  // Helper function to generate unique chat key
+  getChatKey(surveyId: string, userId: string): string {
+    return `${surveyId}_${userId}`;
+  },
+
+  async sendMessage(chatId: string, message: string, userId: string) {
     try {
-      console.log('Starting sendMessage with:', { chatId, message });
+      console.log('Starting sendMessage with:', { chatId, message, userId });
       
       // Validate API key
       if (!config.openaiApiKey || config.openaiApiKey.length < 10) {
@@ -32,9 +40,11 @@ export const chatService = {
         throw new Error('OpenAI API key is not properly configured. Please check your configuration.');
       }
 
+      const chatKey = this.getChatKey(chatId, userId);
+
       // Get or create chat context
-      if (!this.chatContexts.has(chatId)) {
-        console.log('Creating new chat context for:', chatId);
+      if (!this.chatContexts.has(chatKey)) {
+        console.log('Creating new chat context for:', chatKey);
         
         // Fetch survey data from Firestore
         const surveyRef = doc(db, 'companies/LEyaRS2Mv7CLzP20K0Pe/surveys', chatId);
@@ -43,6 +53,7 @@ export const chatService = {
         
         // Fetch questions
         const questions = await getSurveyQuestions(chatId);
+        console.log('Fetched questions:', questions);
         
         let initialMessage = 'Hi! I\'d like to get your feedback on ';
         
@@ -57,12 +68,26 @@ export const chatService = {
         
         initialMessage += ' Would you like to share your thoughts?';
 
-        this.chatContexts.set(chatId, {
+        // Create a new chat document in Firebase
+        const chatRef = await addDoc(collection(db, `users/${userId}/chats`), {
+          surveyId: chatId,
+          createdAt: Date.now(),
+          messages: [{
+            role: 'assistant',
+            content: initialMessage,
+            timestamp: Date.now()
+          }]
+        });
+
+        this.chatContexts.set(chatKey, {
           chatId,
+          userId,
+          chatDocId: chatRef.id,
           messages: [
             {
               role: 'assistant',
-              content: initialMessage
+              content: initialMessage,
+              timestamp: Date.now()
             }
           ],
           currentQuestionIndex: -1,
@@ -74,33 +99,63 @@ export const chatService = {
         });
       }
 
-      const context = this.chatContexts.get(chatId)!;
+      const context = this.chatContexts.get(chatKey)!;
       console.log('Current context:', context);
 
-      // Add user message to context
-      context.messages.push({
-        role: 'user',
-        content: message
-      });
+      // Add user message to context and Firebase
+      const userMessage = {
+        role: 'user' as const,
+        content: message,
+        timestamp: Date.now()
+      };
+      context.messages.push(userMessage);
       context.lastMessageTime = Date.now();
 
+      // Update Firebase with the new message using the stored chat document ID
+      const chatRef = doc(db, `users/${userId}/chats/${context.chatDocId}`);
+      await updateDoc(chatRef, {
+        messages: arrayUnion(userMessage)
+      });
+
       // Handle different conversation states
       switch (context.conversationState) {
         case 'initial':
           if (message.toLowerCase().includes('yes') || 
               message.toLowerCase().includes('sure') || 
               message.toLowerCase().includes('ok') || 
-              message.toLowerCase().includes('alright')) {
+              message.toLowerCase().includes('alright') ||
+              message.toLowerCase().includes('like it') ||
+              message.toLowerCase() === 'maybe') {
             context.conversationState = 'asking';
             context.currentQuestionIndex = 0;
             const nextQuestion = context.questions[0];
-            context.messages.push({
-              role: 'assistant',
-              content: nextQuestion.questionText
+            const assistantMessage = {
+              role: 'assistant' as const,
+              content: nextQuestion.questionText,
+              timestamp: Date.now()
+            };
+            context.messages.push(assistantMessage);
+            
+            // Update Firebase with the assistant's message
+            await updateDoc(chatRef, {
+              messages: arrayUnion(assistantMessage)
             });
+            
             return nextQuestion.questionText;
           } else {
-            return "I understand. Let me know if you change your mind and would like to participate in the survey.";
+            const declineMessage = {
+              role: 'assistant' as const,
+              content: "I understand. Let me know if you change your mind and would like to participate in the survey.",
+              timestamp: Date.now()
+            };
+            context.messages.push(declineMessage);
+            
+            // Update Firebase with the assistant's message
+            await updateDoc(chatRef, {
+              messages: arrayUnion(declineMessage)
+            });
+            
+            return declineMessage.content;
           }
 
         case 'asking':
@@ -109,27 +164,62 @@ export const chatService = {
           context.userResponses[currentQuestion.id] = message;
 
           // Get GPT response based on the conversation context
-          const gptResponse = await this.getGPTResponse(context.messages);
-          context.messages.push({
-            role: 'assistant',
-            content: gptResponse
+          const gptResponse = await this.getGPTResponse([
+            ...context.messages,
+            {
+              role: 'system',
+              content: 'You are discussing the current survey question. Engage naturally with the user\'s response. If the conversation about this topic seems complete, naturally transition to the next question.',
+              timestamp: Date.now()
+            }
+          ]);
+
+          const assistantMessage = {
+            role: 'assistant' as const,
+            content: gptResponse,
+            timestamp: Date.now()
+          };
+          context.messages.push(assistantMessage);
+          
+          // Update Firebase with the assistant's message
+          await updateDoc(chatRef, {
+            messages: arrayUnion(assistantMessage)
           });
 
-          // If we've asked all questions, move to complete state
-          if (context.currentQuestionIndex === context.questions.length - 1) {
-            context.conversationState = 'complete';
-          } else {
+          // Check if we should move to the next question
+          const shouldMoveToNextQuestion = 
+            gptResponse.toLowerCase().includes('next question') || 
+            gptResponse.toLowerCase().includes('moving on') ||
+            gptResponse.toLowerCase().includes('let\'s move on') ||
+            // Add a message count check to prevent getting stuck
+            context.messages.filter(m => m.role === 'user').length > 3;
+
+          if (shouldMoveToNextQuestion) {
+            // If we've asked all questions, move to complete state
+            if (context.currentQuestionIndex >= context.questions.length - 1) {
+              context.conversationState = 'complete';
+              return gptResponse;
+            }
+
+            // Move to next question
             context.currentQuestionIndex++;
             const nextQuestion = context.questions[context.currentQuestionIndex];
-            context.messages.push({
-              role: 'assistant',
-              content: nextQuestion.questionText
+            console.log('Moving to next question:', nextQuestion);
+            
+            const nextQuestionMessage = {
+              role: 'assistant' as const,
+              content: nextQuestion.questionText,
+              timestamp: Date.now()
+            };
+            context.messages.push(nextQuestionMessage);
+            
+            // Update Firebase with the next question
+            await updateDoc(chatRef, {
+              messages: arrayUnion(nextQuestionMessage)
             });
+            
             return nextQuestion.questionText;
           }
 
-          return gptResponse;
-
         case 'complete':
           // Continue conversation with GPT responses
           const finalResponse = await this.getGPTResponse([
@@ -138,13 +228,23 @@ export const chatService = {
               role: 'system',
               content: context.hasAskedForAdditionalFeedback 
                 ? 'Respond naturally to the user\'s feedback. If they haven\'t provided any additional feedback yet, ask again if they have any other thoughts or questions about the survey topic.'
-                : 'Respond naturally to the user\'s feedback. If the conversation seems to be concluding naturally (e.g., user has provided a comprehensive response or seems satisfied), ask if they have any additional feedback or questions about the survey topic. Otherwise, continue the conversation naturally.'
+                : 'Respond naturally to the user\'s feedback. If the conversation seems to be concluding naturally (e.g., user has provided a comprehensive response or seems satisfied), ask if they have any additional feedback or questions about the survey topic. Otherwise, continue the conversation naturally.',
+              timestamp: Date.now()
             }
           ]);
-          context.messages.push({
-            role: 'assistant',
-            content: finalResponse
+
+          const finalMessage = {
+            role: 'assistant' as const,
+            content: finalResponse,
+            timestamp: Date.now()
+          };
+          context.messages.push(finalMessage);
+          
+          // Update Firebase with the final message
+          await updateDoc(chatRef, {
+            messages: arrayUnion(finalMessage)
           });
+          
           if (!context.hasAskedForAdditionalFeedback) {
             context.hasAskedForAdditionalFeedback = true;
           }
@@ -156,45 +256,76 @@ export const chatService = {
     }
   },
 
-  async getGPTResponse(messages: Message[]): Promise<string> {
+  async getGPTResponse(messages: Message[], retryCount = 0): Promise<string> {
     try {
-      const response = await fetch('https://api.openai.com/v1/chat/completions', {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-          'Authorization': `Bearer ${config.openaiApiKey}`
-        },
-        body: JSON.stringify({
-          model: 'gpt-3.5-turbo',
-          messages: [
-            {
-              role: 'system',
-              content: 'You are a friendly and engaging survey assistant. Your goal is to have a natural conversation while gathering feedback. Ask follow-up questions when appropriate, show genuine interest in the responses, and maintain a conversational tone. Keep responses concise but engaging. When the conversation naturally concludes, ask if the user has any additional feedback or questions about the survey topic.'
-            },
-            ...messages
-          ],
-          temperature: 0.7,
-          max_tokens: 150
-        })
-      });
-
-      if (!response.ok) {
-        throw new Error('Failed to get response from OpenAI');
+      // Ensure we have a valid API key
+      if (!config.openaiApiKey) {
+        console.error('OpenAI API key is missing');
+        throw new Error('OpenAI API key is not configured');
       }
 
-      const data = await response.json();
-      return data.choices[0].message.content;
+      const requestBody = {
+        model: 'gpt-3.5-turbo',
+        messages: [
+          {
+            role: 'system',
+            content: 'You are a friendly and engaging survey assistant. Your goal is to have a natural conversation while gathering feedback. Ask follow-up questions when appropriate, show genuine interest in the responses, and maintain a conversational tone. Keep responses concise but engaging. If the conversation about the current topic seems complete, naturally transition to the next question.'
+          },
+          ...messages.filter(msg => msg.role === 'user' || msg.role === 'assistant')
+        ],
+        temperature: 0.7,
+        max_tokens: 150
+      };
+
+      try {
+        const response = await fetch('https://api.openai.com/v1/chat/completions', {
+          method: 'POST',
+          headers: {
+            'Content-Type': 'application/json',
+            'Authorization': `Bearer ${config.openaiApiKey}`,
+            'Accept': 'application/json'
+          },
+          body: JSON.stringify(requestBody)
+        });
+
+        if (!response.ok) {
+          const errorData = await response.json().catch(() => ({ error: { message: 'Failed to parse error response' } }));
+          console.error('OpenAI API error response:', errorData);
+          throw new Error(`OpenAI API error: ${errorData.error?.message || 'Unknown error'}`);
+        }
+
+        const data = await response.json();
+        return data.choices[0].message.content;
+      } catch (networkError) {
+        console.error('Network error in getGPTResponse:', networkError);
+        
+        // Retry up to 3 times with exponential backoff
+        if (retryCount < 3) {
+          console.log(`Retrying GPT request (attempt ${retryCount + 1})...`);
+          await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 1000));
+          return this.getGPTResponse(messages, retryCount + 1);
+        }
+
+        // If all retries failed, move to next question
+        const lastMessage = messages[messages.length - 1];
+        if (lastMessage && lastMessage.role === 'user') {
+          return "Thank you for sharing that. Let's move on to the next question.";
+        }
+        return "I understand. Please continue with your thoughts.";
+      }
     } catch (error) {
-      console.error('Error getting GPT response:', error);
+      console.error('Error in getGPTResponse:', error);
       return "I understand. Please continue with your thoughts.";
     }
   },
 
-  clearContext(chatId: string) {
-    this.chatContexts.delete(chatId);
+  clearContext(chatId: string, userId: string) {
+    const chatKey = this.getChatKey(chatId, userId);
+    this.chatContexts.delete(chatKey);
   },
 
-  getContext(chatId: string) {
-    return this.chatContexts.get(chatId)?.messages || [];
+  getContext(chatId: string, userId: string) {
+    const chatKey = this.getChatKey(chatId, userId);
+    return this.chatContexts.get(chatKey)?.messages || [];
   }
 }; 
\ No newline at end of file
